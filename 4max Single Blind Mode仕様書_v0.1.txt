1. このバージョンの目的

デッキ抽選ロジック

重み付きデッキ

ボード先確定

全プレイヤー同分布（席順非依存）
を、実装可能なレベルで厳密化する

アクション順序・終了条件
を NLHE 準拠で明文化する

一部、未決定事項（棄却回数の上限など）は TBD として明示 する

2. デッキ仕様（ver0.2 詳細）
2.1 基本方針の要約

52枚デックをシャッフル

最初にボード用カード10枚を一様ランダムで確定

そのあと、全プレイヤーのハンドを「同じデックから独立に」重み付き抽選

抽選時点では、

他プレイヤーのハンド

ボードカード
を除外しない（＝「前の座席で使われたカードを取り除かない」）

最後に

各プレイヤーハンド同士

ボードカード
の間に 重複カードがあれば「棄却」→ 再抽選

これにより、

全プレイヤーのハンド分布は 完全に対称（席順依存なし）

ボードは NLHE と同一の一様分布
を両立する。

2.2 手札クラスキーと重み
2.2.1 クラスキー（classKey）

ランクが同じ："AA", "99" など

ランクが異なる：

高いランクを左に置く（A > K > Q > … > 2）

スート一致 → "s"

スート不一致 → "o"

例："AKs", "JTo", "QJs"

2.2.2 重みテーブル handWeights.json
{
  "AA":  { "superDense": 1.00, "dense": 1.00 },
  "AKs": { "superDense": 0.85, "dense": 1.00 },
  "QJo": { "superDense": 0.25, "dense": 0.70 },
  "72o": { "superDense": 0.00, "dense": 0.10 }
}


各値は 任意の非負実数 を許容（整数・小数どちらもOK）

0 → 抽選対象外（事実上の「不許可ハンド」）

ゲーム内では 正規化して利用（weight / Σweight）

バランス調整段階では 絶対値は気にせず比率だけ考えればよい

2.3 ボードカードの先行確定
2.3.1 アルゴリズム

標準 52 枚デックをシャッフル

先頭 10 枚を boardReserved[0..9] として確定

boardReserved[0..2] → フロップ

boardReserved[3] → ターン

boardReserved[4] → リバー

boardReserved[5..9] → 内部的な「焼きカード」相当（公開しないが将棋の感覚として「裏で燃えている」とイメージしておく）

2.3.2 性質

フロップ/ターン/リバー 5 枚の分布は
通常 NLHE のそれと完全に一致

ハンド抽選とボード確定の順番を入れ替えても
確率構造的には等価だが、
ボードを先に固定することで実装ロジックをシンプル化する。

2.4 コンボ数と「複合重み」

ここが ver0.2 のキモ。

2.4.1 コンボ数 combos(classKey)

各 classKey に対して、
物理デック上で取り得る 2枚組（コンボ）の数を数える

例：

AA → 6 通り

AKs → 4 通り

AKo → 12 通り

72o → 12 通り

2.4.2 抽選に用いる「複合重み」

✅ 仕様決定：
抽選重み = クラス重み × コンボ数

形式的には：

effectiveWeight(classKey) = handWeight[classKey][mode] * combos(classKey)


mode："superDense" など

この effectiveWeight をルーレットの重みとして使う

これにより、

「クラスとして好ましい」かつ

「取りうるコンボ数が多い」クラスほど
自然に出現頻度が高くなる

2.5 プレイヤーハンド抽選（全員同じデック＋棄却法）

ここが ②の回答を反映した部分。

2.5.1 準備

boardReserved は既に 10 枚確定済

全 52 枚から 2 枚組コンボを全列挙し、
classKey ごとのリストを構築：

// 疑似コードイメージ
const combosByClass: { [classKey: string]: Card[][] } = {};
for (const c1 of deck52) {
  for (const c2 of deck52) {
    if (c1 < c2) { // 2枚の順序を固定
      const key = getClassKey(c1, c2);
      combosByClass[key].push([c1, c2]);
    }
  }
}


✅ この時点では ボードカードは除外しない。
「全員同じデックから取得」という仕様を守るため、
コンボ列挙は 常にフルデック 52 枚で行う。

各 classKey について
combos(classKey) = combosByClass[key].length を計算

有効クラス（重み > 0）の effectiveWeight(classKey) を計算し、
全クラスの totalEffectiveWeight を求める。

2.5.2 1回分の「全プレイヤーハンド抽選」手順

ここでいう「1回分」は 4人全員のハンドをまとめて引く一試行。

各プレイヤーに対して、以下を独立に行う：
1.1 ルーレットで classKey を抽選
effectiveWeight を用いる
1.2 combosByClass[classKey] から
均等ランダムで 1 コンボ（2枚）を選択
1.3 その2枚を「暫定 holeCards」として保持
（まだ重複チェックはしない）

4人分の暫定 holeCards と boardReserved[0..9] を合わせて
カード重複チェック を行う：

任意の2枚が同じカードなら「重複あり」

条件：

プレイヤー同士のハンドの重複

プレイヤーハンドとボード予約カードの重複
をすべて禁止する

重複が一切なければ、この4ハンドを採用して成功

1枚でも重複があれば、この試行を 丸ごと棄却 し、

からやり直す（新しい乱数で再抽選）

✅ ポイント：

抽選そのものは「全プレイヤー独立＋同一分布」

その後に「物理的にありえない状態（重複）だけ除去する」
→ 条件付き分布の形で 公平・対称なハンド分布 が実現される。

2.5.3 棄却回数の上限（現時点）

現時点では仕様未確定（TBD）

ただし、実装ガイドラインとして以下を推奨メモとして残す：

推奨案：

1ハンド生成試行あたりの最大リトライ数を 128 回程度に設定

それを超えた場合はログに警告を出しつつ、
「残っているコンボから均等ランダムで物理的に整合する組を探す」
などのフォールバックを行う

本仕様書 ver0.2 では あくまでメモ扱い とし、
正式仕様は ver0.3 以降で決定する。

3. アクション仕様（NLHE 準拠の明文化）

⑤A を反映して、
NLHE と同じ挙動を、そのまま Dense Deck 仕様書に書き下します。

3.1 アクターの順序
プリフロップ

最初に行動するプレイヤー：UTG（BB の左）

最後に行動するプレイヤー：BB

以降の順番：UTG → CO → BTN → BB（シングルブラインド）

フロップ / ターン / リバー

最初のアクター：UTG

以降：UTG → CO → BTN → BB（※BB はプリフロップ以外は最後）

ただし、すでにフォールド or オールインのプレイヤーはスキップ

3.2 アクション終了条件（ストリートの終わり）

各ストリートは、次の両方を満たした時に終了する：

ポットに対する各プレイヤーの投入額が等しい

ここでの比較対象は「そのストリート開始以降の追加額」ではなく、
「そのストリート終了時点までの合計投入額」。

全プレイヤーが一度は行動を完了している

例：

チェック

コール

ベット／レイズ後のフォールド or コール

オールイン

3.3 ベット・レイズのルール

ベット・レイズ額は NLHE の標準ルールに従う

最小レイズ幅：直前のベット / レイズ額と同じ差額以上

上限：残りスタック（オールイン）

MVP 実装では、

プリフロップのオープンサイズ：3BB 固定

3bet/4bet：コールに必要な額の3倍 を推奨デフォルトサイズとする
（AIの挙動仕様として）

4. ステートマシン（簡易）
GameStart
  ↓
Shuffle + BoardReserved(10枚)確定
  ↓
HandSampling（重み付き抽選＋棄却ループ）
  ↓
PreflopAction
  ↓
FlopAction（boardReserved[0..2]）
  ↓
TurnAction（boardReserved[3]）
  ↓
RiverAction（boardReserved[4]）
  ↓
Showdown
  ↓
Payout
  ↓
HandEnd

5. ver0.2 の「未決事項」一覧（To Be Discussed）

棄却回数上限とフォールバックアルゴリズム

指標例：maxRetries = 128 / hand

それ以上のリトライが必要になる状況は極めてレアだが、
数学仕様書との整合を見ながら慎重に決める。

モード別 handWeights の具体値設計

Super Dense / Dense / Full Deck それぞれの重みプロファイル

「どのクラスを 0 にするか」「どこを厚くするか」など

これはゲームデザインと数学仕様書側で詰める領域。